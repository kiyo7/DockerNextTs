-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE TABLE IF NOT EXISTS public.members
(
    organization_id uuid NOT NULL,
    member_id uuid NOT NULL,
    CONSTRAINT members_pkey PRIMARY KEY (member_id),
    CONSTRAINT member_id_fkey FOREIGN KEY (member_id)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT members_organization_id_fkey FOREIGN KEY (organization_id)
        REFERENCES public.organizations (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.members
    OWNER to postgres;

GRANT ALL ON TABLE public.members TO anon;

GRANT ALL ON TABLE public.members TO authenticated;

GRANT ALL ON TABLE public.members TO postgres;

GRANT ALL ON TABLE public.members TO service_role;

CREATE TABLE IF NOT EXISTS public.organizations
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    administrator uuid NOT NULL,
    groupname text COLLATE pg_catalog."default",
    logo text COLLATE pg_catalog."default",
    CONSTRAINT organizations_pkey PRIMARY KEY (id),
    CONSTRAINT administrator_id_fkey FOREIGN KEY (administrator)
        REFERENCES public.profiles (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.organizations
    OWNER to postgres;

ALTER TABLE IF EXISTS public.organizations
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.organizations TO anon;

GRANT ALL ON TABLE public.organizations TO authenticated;

GRANT ALL ON TABLE public.organizations TO postgres;

GRANT ALL ON TABLE public.organizations TO service_role;
CREATE POLICY "Enable delete for users based on administrator"
    ON public.organizations
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = administrator));
CREATE POLICY "Public organizations are viewable by everyone."
    ON public.organizations
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Users can insert their own profile."
    ON public.organizations
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = administrator));
CREATE POLICY "Users can update own profile."
    ON public.organizations
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = administrator));

CREATE TABLE IF NOT EXISTS public.profiles
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    username text COLLATE pg_catalog."default",
    avatar text COLLATE pg_catalog."default",
    is_admin boolean,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone,
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profiles
    OWNER to postgres;

ALTER TABLE IF EXISTS public.profiles
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profiles TO anon;

GRANT ALL ON TABLE public.profiles TO authenticated;

GRANT ALL ON TABLE public.profiles TO postgres;

GRANT ALL ON TABLE public.profiles TO service_role;
CREATE POLICY "Public profiles are viewable by everyone."
    ON public.profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Users can insert their own profile."
    ON public.profiles
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = id));
CREATE POLICY "Users can update own profile."
    ON public.profiles
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id));

CREATE TRIGGER handle_updated_at
    BEFORE UPDATE 
    ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION extensions.moddatetime('updated_at');
